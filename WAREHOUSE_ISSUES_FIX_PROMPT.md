# üîß –ü–†–û–ú–ü–¢ –î–õ–Ø –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø –ü–†–û–ë–õ–ï–ú –°–û –°–ö–õ–ê–î–ê–ú–ò –í WILDBERRIES STOCK TRACKER

**–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è**: 23 –æ–∫—Ç—è–±—Ä—è 2025 –≥.  
**–°—Ç–∞—Ç—É—Å**: –¢—Ä–µ–±—É–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏  
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç**: –í—ã—Å–æ–∫–∏–π  

## üéØ –ê–ù–ê–õ–ò–ó –¢–ï–ö–£–©–ò–• –ü–†–û–ë–õ–ï–ú

### –ü—Ä–æ–±–ª–µ–º–∞ 1: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —Å–∫–ª–∞–¥—ã –ø—Ä–æ–¥–∞–≤—Ü–∞ (–ú–ü)
**–û–ø–∏—Å–∞–Ω–∏–µ**: –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç –æ—Å—Ç–∞—Ç–∫–∏ —Ç–æ–ª—å–∫–æ –Ω–∞ —Å–∫–ª–∞–¥–∞—Ö WB, –Ω–æ –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç –æ—Å—Ç–∞—Ç–∫–∏ –Ω–∞ —Å–∫–ª–∞–¥–∞—Ö –°–µ–ª–ª–µ—Ä–∞ (–ú–ü). –í –≥—Ä–∞—Ñ—É "–ù–∞–∑–≤–∞–Ω–∏–µ —Å–∫–ª–∞–¥–∞" –¥–æ–ª–∂–Ω—ã –ø–æ–¥–≥—Ä—É–∂–∞—Ç—å—Å—è —Å–∫–ª–∞–¥—ã —Å–µ–ª–ª–µ—Ä–∞.

**–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø—Ä–∏—á–∏–Ω–∞**: 
- –í `urls.md` API `/supplier/orders` —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–ª–µ `warehouseType` —Å –≤–æ–∑–º–æ–∂–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏:
  - `"–°–∫–ª–∞–¥ WB"`
  - `"–°–∫–ª–∞–¥ –ø—Ä–æ–¥–∞–≤—Ü–∞"`
- –í –∫–æ–¥–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Å–∫–ª–∞–¥–æ–≤ (`src/stock_tracker/core/calculator.py`) –Ω–µ—Ç –ª–æ–≥–∏–∫–∏ –¥–ª—è —Ä–∞–∑–ª–∏—á–µ–Ω–∏—è –∏ –≤–∫–ª—é—á–µ–Ω–∏—è —Å–∫–ª–∞–¥–æ–≤ –ø—Ä–æ–¥–∞–≤—Ü–∞
- –§—É–Ω–∫—Ü–∏—è `is_real_warehouse()` –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç —Å–∫–ª–∞–¥—ã –ú–ü

**–ó–∞—Ç—Ä–æ–Ω—É—Ç—ã–µ —Ñ–∞–π–ª—ã**:
- `src/stock_tracker/core/calculator.py`
- `src/stock_tracker/api/products.py`
- `src/stock_tracker/api/warehouses.py`

### –ü—Ä–æ–±–ª–µ–º–∞ 2: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —Å–∫–ª–∞–¥—ã —Å –Ω—É–ª–µ–≤—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏
**–û–ø–∏—Å–∞–Ω–∏–µ**: –ï—Å–ª–∏ –Ω–∞ —Å–∫–ª–∞–¥–µ 0 –æ—Å—Ç–∞—Ç–∫–æ–≤, –Ω–æ –∑–∞ —Ç–µ–∫—É—â–∏–π –ø–µ—Ä–∏–æ–¥ –µ—Å—Ç—å –∑–∞–∫–∞–∑—ã, —Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –≤—Å–µ —Ä–∞–≤–Ω–æ –Ω–µ –ø–∏—à–µ—Ç —ç—Ç–æ—Ç —Å–∫–ª–∞–¥ –≤ –Ω–∞–∑–≤–∞–Ω–∏—è.

**–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø—Ä–∏—á–∏–Ω–∞**: 
- API `/warehouse_remains` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Å–∫–ª–∞–¥—ã —Å `quantity > 0` (—Å–æ–≥–ª–∞—Å–Ω–æ `urls.md`: "–ë—É–¥—É—Ç –≤ –æ—Ç–≤–µ—Ç–µ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–µ–Ω—É–ª–µ–≤–æ–º quantity")
- –ó–∞–∫–∞–∑—ã –º–æ–≥—É—Ç –±—ã—Ç—å —Å–æ —Å–∫–ª–∞–¥–æ–≤ —Å –Ω—É–ª–µ–≤—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏
- –õ–æ–≥–∏–∫–∞ `group_data_by_product()` –Ω–µ —Å–æ–∑–¥–∞–µ—Ç –∑–∞–ø–∏—Å–∏ —Å–∫–ª–∞–¥–æ–≤ –¥–ª—è –∑–∞–∫–∞–∑–æ–≤ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –æ—Å—Ç–∞—Ç–∫–æ–≤

**–ó–∞—Ç—Ä–æ–Ω—É—Ç—ã–µ —Ñ–∞–π–ª—ã**:
- `src/stock_tracker/core/calculator.py` (—Ñ—É–Ω–∫—Ü–∏—è `group_data_by_product`)
- `src/stock_tracker/api/warehouses.py`

### –ü—Ä–æ–±–ª–µ–º–∞ 3: –ù–µ—Ç–æ—á–Ω—ã–π –ø–æ–¥—Å—á–µ—Ç –∑–∞–∫–∞–∑–æ–≤
**–û–ø–∏—Å–∞–Ω–∏–µ**: "–ó–∞–∫–∞–∑—ã (–≤—Å–µ–≥–æ)" –∏ "–ó–∞–∫–∞–∑—ã —Å–æ —Å–∫–ª–∞–¥–∞" –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏. 

**–ü—Ä–∏–º–µ—Ä—ã —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–π**:
- –ê—Ä—Ç–∏–∫—É–ª 163383326: WB –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç 98 –∑–∞–∫–∞–∑–æ–≤ –≤—Å–µ–≥–æ, –∞ —Ç–∞–±–ª–∏—Ü–∞ 108
- –ö–æ—Ç–æ–≤—Å–∫ –ø–æ —ç—Ç–æ–º—É –∞—Ä—Ç–∏–∫—É–ª—É: WB –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç 18 –∑–∞–∫–∞–∑–æ–≤, –∞ —Ç–∞–±–ª–∏—Ü–∞ 27

**–í–æ–∑–º–æ–∂–Ω—ã–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏—á–∏–Ω—ã**:
1. –û—à–∏–±–∫–∏ –≤ –ª–æ–≥–∏–∫–µ –ø–æ–¥—Å—á–µ—Ç–∞ –≤ `calculate_total_orders()` –∏ `calculate_warehouse_orders()`
2. –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–µ—Ä–∏–æ–¥–∞ (`dateFrom` –ø–∞—Ä–∞–º–µ—Ç—Ä)
3. –†–∞–∑–ª–∏—á–∏–µ –≤ –ª–æ–≥–∏–∫–µ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ WB –∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
4. –í–∫–ª—é—á–µ–Ω–∏–µ/–∏—Å–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤ (`isCancel` –ø–æ–ª–µ)
5. –†–∞–∑–ª–∏—á–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ `warehouseType`

**–ó–∞—Ç—Ä–æ–Ω—É—Ç—ã–µ —Ñ–∞–π–ª—ã**:
- `src/stock_tracker/core/calculator.py`
- `src/stock_tracker/api/products.py`

## ‚úÖ –¢–†–ï–ë–£–ï–ú–´–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø

### 1. –î–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–¥–µ—Ä–∂–∫—É —Å–∫–ª–∞–¥–æ–≤ –ø—Ä–æ–¥–∞–≤—Ü–∞ (–ú–ü)

#### 1.1. –û–±–Ω–æ–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Å–∫–ª–∞–¥–æ–≤

**–§–∞–π–ª**: `src/stock_tracker/core/calculator.py`

**–ò–∑–º–µ–Ω–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é** `is_real_warehouse()`:

```python
def is_real_warehouse(warehouse_name: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —ç—Ç–æ —Ä–µ–∞–ª—å–Ω—ã–π —Å–∫–ª–∞–¥, –∞ –Ω–µ —Å—Ç–∞—Ç—É—Å."""
    if not warehouse_name or not isinstance(warehouse_name, str):
        return False
    
    # –ò—Å–∫–ª—é—á–∞–µ–º —Å—Ç–∞—Ç—É—Å—ã –¥–æ—Å—Ç–∞–≤–∫–∏
    if warehouse_name in DELIVERY_STATUSES:
        return False
        
    # –ò—Å–∫–ª—é—á–∞–µ–º –∏—Ç–æ–≥–æ–≤—ã–µ —Å—Ç—Ä–æ–∫–∏
    if any(word in warehouse_name.lower() for word in ["–∏—Ç–æ–≥", "–≤—Å–µ–≥–æ", "–æ–±—â–∏–π"]):
        return False
        
    # –ò—Å–∫–ª—é—á–∞–µ–º —Å—Ç—Ä–æ–∫–∏ "–≤ –ø—É—Ç–∏"
    if "–≤ –ø—É—Ç–∏" in warehouse_name.lower():
        return False
    
    # –î–û–ë–ê–í–ò–¢–¨: –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Å–∫–ª–∞–¥–æ–≤ –ø—Ä–æ–¥–∞–≤—Ü–∞ (–ú–ü)
    # –°–∫–ª–∞–¥—ã –ø—Ä–æ–¥–∞–≤—Ü–∞ –∏–º–µ—é—Ç —Ç–∏–ø–∏—á–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è
    mp_indicators = ["–º–ø", "–º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å", "—Å–∫–ª–∞–¥ –ø—Ä–æ–¥–∞–≤—Ü–∞", "—Å–ø ", "sp "]
    warehouse_name_lower = warehouse_name.lower()
    
    # –ï—Å–ª–∏ —ç—Ç–æ —Å–∫–ª–∞–¥ –ú–ü - —Ç–æ—á–Ω–æ –≤–∫–ª—é—á–∞–µ–º
    if any(indicator in warehouse_name_lower for indicator in mp_indicators):
        logger.debug(f"Identified MP warehouse: {warehouse_name}")
        return True
    
    # –û—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –æ–±—ã—á–Ω—ã—Ö —Å–∫–ª–∞–¥–æ–≤
    return True
```

#### 1.2. –î–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É warehouseType –≤ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–µ –∑–∞–∫–∞–∑–æ–≤

**–§–∞–π–ª**: `src/stock_tracker/core/calculator.py`

**–ò–∑–º–µ–Ω–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é** `group_data_by_product()` –≤ —á–∞—Å—Ç–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–∫–∞–∑–æ–≤:

```python
# Process orders data to count orders per warehouse and total
for order in orders_data:
    nm_id = order.get("nmId")
    supplier_article = order.get("supplierArticle", "")
    warehouse_name = order.get("warehouseName", "")
    warehouse_type = order.get("warehouseType")  # –ù–û–í–û–ï –ü–û–õ–ï
    
    if nm_id and supplier_article:
        key = (supplier_article, nm_id)
        group = grouped_data[key]
        group["supplier_article"] = supplier_article
        group["nm_id"] = nm_id
        
        # Count total orders
        group["total_orders"] += 1
        
        # Count orders per warehouse
        if warehouse_name:
            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –í–∫–ª—é—á–∞–µ–º —Å–∫–ª–∞–¥—ã –ø—Ä–æ–¥–∞–≤—Ü–∞
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø —Å–∫–ª–∞–¥–∞ –∏–∑ API
            is_valid_warehouse_type = (
                warehouse_type in ["–°–∫–ª–∞–¥ WB", "–°–∫–ª–∞–¥ –ø—Ä–æ–¥–∞–≤—Ü–∞"] or 
                warehouse_type is None  # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            )
            
            if is_valid_warehouse_type and is_real_warehouse(warehouse_name) and validate_warehouse_name(warehouse_name):
                # –°–û–ó–î–ê–ï–ú –°–ö–õ–ê–î –ï–°–õ–ò –ï–ì–û –ù–ï–¢ (–¥–ª—è —Å–ª—É—á–∞–µ–≤ —Å –Ω—É–ª–µ–≤—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏)
                if warehouse_name not in group["warehouses"]:
                    group["warehouses"][warehouse_name] = {
                        "stock": 0,  # –û—Å—Ç–∞—Ç–∫–∏ = 0, –±—É–¥—É—Ç –æ–±–Ω–æ–≤–ª–µ–Ω—ã –∏–∑ warehouse_remains
                        "orders": 0,
                        "warehouse_type": warehouse_type  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–∏–ø —Å–∫–ª–∞–¥–∞
                    }
                    logger.debug(f"Created warehouse entry for zero-stock warehouse: {warehouse_name} (type: {warehouse_type})")
                
                group["warehouses"][warehouse_name]["orders"] += 1
            else:
                logger.debug(f"Filtered out order warehouse: {warehouse_name} (type: {warehouse_type})")
```

#### 1.3. –û–±–Ω–æ–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –≤ warehouse_remains

**–§–∞–π–ª**: `src/stock_tracker/core/calculator.py`

**–ò–∑–º–µ–Ω–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é** `group_data_by_product()` –≤ —á–∞—Å—Ç–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Å—Ç–∞—Ç–∫–æ–≤:

```python
# Process warehouse remains data
for item in warehouse_remains_data:
    nm_id = item.get("nmId")
    # vendorCode is supplierArticle in warehouse_remains response
    supplier_article = item.get("vendorCode", "")
    
    if nm_id and supplier_article:
        key = (supplier_article, nm_id)
        group = grouped_data[key]
        group["supplier_article"] = supplier_article
        group["nm_id"] = nm_id
        
        # Process warehouses
        if "warehouses" in item:
            for warehouse in item["warehouses"]:
                warehouse_name = warehouse.get("warehouseName", "")
                quantity = warehouse.get("quantity", 0)
                
                # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–∏–º–µ–Ω—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é
                if warehouse_name and is_real_warehouse(warehouse_name):
                    if validate_warehouse_name(warehouse_name):
                        # –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–∫–ª–∞–¥
                        if warehouse_name not in group["warehouses"]:
                            group["warehouses"][warehouse_name] = {
                                "stock": 0,
                                "orders": 0,
                                "warehouse_type": "unknown"  # –ë—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω –∏–∑ orders –µ—Å–ª–∏ –µ—Å—Ç—å
                            }
                        
                        # –û–±–Ω–æ–≤–ª—è–µ–º –æ—Å—Ç–∞—Ç–∫–∏
                        group["warehouses"][warehouse_name]["stock"] += quantity
                        logger.debug(f"Updated warehouse stock: {warehouse_name} += {quantity}")
                    else:
                        logger.warning(f"Invalid warehouse name format: {warehouse_name}")
                else:
                    logger.debug(f"Filtered out warehouse remains: {warehouse_name}")
```

### 2. –í–∫–ª—é—á–∏—Ç—å —Å–∫–ª–∞–¥—ã —Å –Ω—É–ª–µ–≤—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏ –Ω–æ —Å –∑–∞–∫–∞–∑–∞–º–∏

–õ–æ–≥–∏–∫–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –ø—É–Ω–∫—Ç–µ 1.2 –≤—ã—à–µ —á–µ—Ä–µ–∑ —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–µ–π —Å–∫–ª–∞–¥–æ–≤ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–∫–∞–∑–æ–≤:

```python
# –°–û–ó–î–ê–ï–ú –°–ö–õ–ê–î –ï–°–õ–ò –ï–ì–û –ù–ï–¢ (–¥–ª—è —Å–ª—É—á–∞–µ–≤ —Å –Ω—É–ª–µ–≤—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏)
if warehouse_name not in group["warehouses"]:
    group["warehouses"][warehouse_name] = {
        "stock": 0,  # –û—Å—Ç–∞—Ç–∫–∏ = 0
        "orders": 0,
        "warehouse_type": warehouse_type
    }
```

### 3. –ò—Å–ø—Ä–∞–≤–∏—Ç—å –ø–æ–¥—Å—á–µ—Ç –∑–∞–∫–∞–∑–æ–≤

#### 3.1. –î–æ–±–∞–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é —Å –¥–µ—Ç–∞–ª—å–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–æ–π

**–§–∞–π–ª**: `src/stock_tracker/core/calculator.py`

**–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–µ –º–µ—Ç–æ–¥—ã**:

```python
@staticmethod
def calculate_total_orders_with_debug(orders_data: List[Dict[str, Any]], nm_id: int) -> Tuple[int, Dict[str, Any]]:
    """
    Calculate total orders for product with detailed debugging.
    
    Args:
        orders_data: Data from /supplier/orders API
        nm_id: Product nmId to calculate for
        
    Returns:
        Tuple of (order_count, debug_info)
    """
    order_count = 0
    debug_info = {
        "nm_id": nm_id,
        "total_records_checked": len(orders_data),
        "matching_records": [],
        "filtered_out": [],
        "warehouse_breakdown": {},
        "warehouse_type_breakdown": {}
    }
    
    for i, order in enumerate(orders_data):
        order_nm_id = order.get("nmId")
        warehouse_name = order.get("warehouseName", "")
        warehouse_type = order.get("warehouseType", "Unknown")
        is_canceled = order.get("isCancel", False)
        order_date = order.get("date", "")
        
        if order_nm_id == nm_id:
            # –î–µ—Ç–∞–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∫–∞–∂–¥–æ–≥–æ –∑–∞–∫–∞–∑–∞
            order_info = {
                "warehouse": warehouse_name,
                "type": warehouse_type,
                "canceled": is_canceled,
                "date": order_date,
                "index": i
            }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –∫–∞–∫ –≤ WB
            if is_canceled:
                debug_info["filtered_out"].append({
                    **order_info,
                    "reason": "canceled_order"
                })
                continue
            
            # –§–∏–ª—å—Ç—Ä –ø–æ —Ç–∏–ø—É —Å–∫–ª–∞–¥–∞ (–≤–∫–ª—é—á–∞–µ–º WB –∏ –ú–ü)
            if warehouse_type not in ["–°–∫–ª–∞–¥ WB", "–°–∫–ª–∞–¥ –ø—Ä–æ–¥–∞–≤—Ü–∞"] and warehouse_type != "":
                debug_info["filtered_out"].append({
                    **order_info,
                    "reason": f"unknown_warehouse_type: {warehouse_type}"
                })
                continue
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é —Å–∫–ª–∞–¥–∞
            if not is_real_warehouse(warehouse_name):
                debug_info["filtered_out"].append({
                    **order_info,
                    "reason": f"invalid_warehouse_name: {warehouse_name}"
                })
                continue
            
            # –í–∞–ª–∏–¥–Ω—ã–π –∑–∞–∫–∞–∑ - —Å—á–∏—Ç–∞–µ–º
            order_count += 1
            debug_info["matching_records"].append(order_info)
            
            # –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ —Å–∫–ª–∞–¥–∞–º
            if warehouse_name not in debug_info["warehouse_breakdown"]:
                debug_info["warehouse_breakdown"][warehouse_name] = 0
            debug_info["warehouse_breakdown"][warehouse_name] += 1
            
            # –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ —Ç–∏–ø–∞–º —Å–∫–ª–∞–¥–æ–≤
            if warehouse_type not in debug_info["warehouse_type_breakdown"]:
                debug_info["warehouse_type_breakdown"][warehouse_type] = 0
            debug_info["warehouse_type_breakdown"][warehouse_type] += 1
    
    debug_info["total_orders_calculated"] = order_count
    debug_info["wb_warehouses"] = sum(count for wh, count in debug_info["warehouse_breakdown"].items() 
                                     if not any(mp in wh.lower() for mp in ["–º–ø", "–º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å", "—Å–∫–ª–∞–¥ –ø—Ä–æ–¥–∞–≤—Ü–∞"]))
    debug_info["mp_warehouses"] = debug_info["total_orders_calculated"] - debug_info["wb_warehouses"]
    
    logger.info(f"üîç DEBUG orders for nmId {nm_id}:")
    logger.info(f"   Total API records: {debug_info['total_records_checked']}")
    logger.info(f"   Matching orders: {order_count}")
    logger.info(f"   - WB warehouses: {debug_info['wb_warehouses']}")
    logger.info(f"   - MP warehouses: {debug_info['mp_warehouses']}")
    logger.info(f"   Warehouse breakdown: {debug_info['warehouse_breakdown']}")
    logger.info(f"   Type breakdown: {debug_info['warehouse_type_breakdown']}")
    logger.info(f"   Filtered out: {len(debug_info['filtered_out'])} records")
    
    return order_count, debug_info

@staticmethod
def validate_orders_calculation(nm_id: int, calculated_total: int, 
                              calculated_by_warehouse: Dict[str, int]) -> Dict[str, Any]:
    """
    Validate that warehouse orders sum equals total orders.
    
    Args:
        nm_id: Product nmId
        calculated_total: Total orders calculated
        calculated_by_warehouse: Orders per warehouse
        
    Returns:
        Validation report
    """
    warehouse_sum = sum(calculated_by_warehouse.values())
    is_valid = warehouse_sum == calculated_total
    
    validation = {
        "nm_id": nm_id,
        "calculated_total": calculated_total,
        "warehouse_sum": warehouse_sum,
        "difference": abs(warehouse_sum - calculated_total),
        "is_valid": is_valid,
        "warehouse_breakdown": calculated_by_warehouse
    }
    
    if not is_valid:
        logger.warning(f"‚ö†Ô∏è Orders validation failed for nmId {nm_id}:")
        logger.warning(f"   Total calculated: {calculated_total}")
        logger.warning(f"   Warehouse sum: {warehouse_sum}")
        logger.warning(f"   Difference: {validation['difference']}")
        logger.warning(f"   Warehouse breakdown: {calculated_by_warehouse}")
    else:
        logger.info(f"‚úÖ Orders validation passed for nmId {nm_id}")
    
    return validation
```

#### 3.2. –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–Ω—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –ø–æ –¥–∞—Ç–µ

**–§–∞–π–ª**: `src/stock_tracker/api/products.py`

**–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥**:

```python
async def fetch_supplier_orders_precise(self, date_from: str, 
                                      date_to: Optional[str] = None,
                                      flag: int = 0,
                                      include_canceled: bool = False) -> List[Dict[str, Any]]:
    """
    Fetch supplier orders with precise date filtering to match WB logic.
    
    Args:
        date_from: Start date in RFC3339 format
        date_to: End date (optional, for range filtering)
        flag: Query flag (0 for incremental, 1 for full day data)
        include_canceled: Whether to include canceled orders (default: False like WB)
        
    Returns:
        List of order records filtered by date range and cancellation status
        
    Raises:
        APIError: If API request fails
        ValidationError: If parameters are invalid
    """
    try:
        logger.info(f"Fetching precise orders: {date_from} to {date_to or 'latest'}, "
                   f"include_canceled: {include_canceled}")
        
        # Get raw data from API
        response_data = await self.fetch_supplier_orders(date_from, flag)
        
        filtered_orders = []
        stats = {
            "raw_count": len(response_data),
            "canceled_filtered": 0,
            "date_filtered": 0,
            "final_count": 0
        }
        
        for order in response_data:
            # Filter canceled orders if required (matching WB logic)
            if not include_canceled and order.get("isCancel", False):
                stats["canceled_filtered"] += 1
                continue
            
            # Filter by date range if date_to provided
            if date_to:
                order_date = order.get("date", "")
                if order_date and order_date > date_to:
                    stats["date_filtered"] += 1
                    continue
            
            filtered_orders.append(order)
        
        stats["final_count"] = len(filtered_orders)
        
        logger.info(f"Orders filtering stats: {stats}")
        logger.info(f"   Raw from API: {stats['raw_count']}")
        logger.info(f"   Filtered canceled: {stats['canceled_filtered']}")
        logger.info(f"   Filtered by date: {stats['date_filtered']}")
        logger.info(f"   Final count: {stats['final_count']}")
        
        return filtered_orders
        
    except Exception as e:
        logger.error(f"Failed to fetch precise supplier orders: {e}")
        raise APIError(f"Precise orders fetch failed: {e}")
```

### 4. –°–æ–∑–¥–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏

#### 4.1. –°–æ–∑–¥–∞—Ç—å –º–æ–¥—É–ª—å –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Ä–∞—Å—á–µ—Ç–æ–≤

**–°–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª**: `src/stock_tracker/utils/calculation_verifier.py`

```python
"""
Verification utilities for validating calculation accuracy against WB data.

This module provides tools to verify that our calculations match the expected
results from Wildberries interface, helping to identify and fix discrepancies.
"""

from typing import Dict, List, Any, Tuple, Optional
from datetime import datetime, timedelta
import asyncio

from stock_tracker.utils.logger import get_logger
from stock_tracker.core.calculator import WildberriesCalculator

logger = get_logger(__name__)


class CalculationVerifier:
    """Verify calculation accuracy against expected WB results."""
    
    @staticmethod
    def verify_orders_accuracy(nm_id: int, 
                             our_calculation: Dict[str, Any],
                             expected_wb_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify orders calculation accuracy against WB interface data.
        
        Args:
            nm_id: Product nmId being verified
            our_calculation: Our calculated results
            expected_wb_data: Expected results from WB interface
            
        Returns:
            Detailed verification report
        """
        verification = {
            "nm_id": nm_id,
            "timestamp": datetime.now().isoformat(),
            "total_orders": {
                "our_result": our_calculation.get("total_orders", 0),
                "wb_expected": expected_wb_data.get("total_orders", 0),
                "difference": 0,
                "match": False,
                "accuracy_percent": 0.0
            },
            "warehouse_orders": {},
            "overall_accuracy": 0.0,
            "issues_found": [],
            "recommendations": []
        }
        
        # Verify total orders
        our_total = our_calculation.get("total_orders", 0)
        wb_total = expected_wb_data.get("total_orders", 0)
        verification["total_orders"]["difference"] = abs(our_total - wb_total)
        verification["total_orders"]["match"] = our_total == wb_total
        
        if wb_total > 0:
            verification["total_orders"]["accuracy_percent"] = (
                min(our_total, wb_total) / max(our_total, wb_total) * 100
            )
        
        if not verification["total_orders"]["match"]:
            verification["issues_found"].append(
                f"Total orders mismatch: calculated {our_total}, expected {wb_total} "
                f"(difference: {verification['total_orders']['difference']})"
            )
            
            if our_total > wb_total:
                verification["recommendations"].append(
                    "Our calculation is higher - check for duplicate counting or incorrect filtering"
                )
            else:
                verification["recommendations"].append(
                    "Our calculation is lower - check for missing warehouse types or date filtering"
                )
        
        # Verify warehouse-level orders
        our_warehouses = our_calculation.get("warehouse_breakdown", {})
        wb_warehouses = expected_wb_data.get("warehouse_breakdown", {})
        
        all_warehouses = set(our_warehouses.keys()) | set(wb_warehouses.keys())
        
        for warehouse in all_warehouses:
            our_count = our_warehouses.get(warehouse, 0)
            wb_count = wb_warehouses.get(warehouse, 0)
            
            warehouse_accuracy = 0.0
            if max(our_count, wb_count) > 0:
                warehouse_accuracy = min(our_count, wb_count) / max(our_count, wb_count) * 100
            
            verification["warehouse_orders"][warehouse] = {
                "our_result": our_count,
                "wb_expected": wb_count,
                "difference": abs(our_count - wb_count),
                "match": our_count == wb_count,
                "accuracy_percent": warehouse_accuracy
            }
            
            if our_count != wb_count:
                verification["issues_found"].append(
                    f"Warehouse {warehouse}: calculated {our_count}, expected {wb_count} "
                    f"(difference: {abs(our_count - wb_count)})"
                )
        
        # Calculate overall accuracy
        total_matches = sum(1 for result in verification["warehouse_orders"].values() if result["match"])
        total_matches += 1 if verification["total_orders"]["match"] else 0
        total_checks = len(verification["warehouse_orders"]) + 1
        
        verification["overall_accuracy"] = (total_matches / total_checks) * 100 if total_checks > 0 else 0
        
        logger.info(f"Verification for nmId {nm_id}: {verification['overall_accuracy']:.1f}% accurate")
        
        return verification
    
    @staticmethod
    def create_verification_report(verifications: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Create comprehensive verification report for multiple products.
        
        Args:
            verifications: List of verification results
            
        Returns:
            Comprehensive report with statistics and recommendations
        """
        if not verifications:
            return {"error": "No verifications provided"}
        
        report = {
            "timestamp": datetime.now().isoformat(),
            "products_verified": len(verifications),
            "overall_accuracy": 0.0,
            "accuracy_by_product": {},
            "common_issues": {},
            "accuracy_distribution": {"perfect": 0, "good": 0, "fair": 0, "poor": 0},
            "recommendations": [],
            "summary_statistics": {
                "total_orders_our": 0,
                "total_orders_wb": 0,
                "total_difference": 0
            }
        }
        
        total_accuracy = 0
        issue_counts = {}
        total_our = 0
        total_wb = 0
        
        for verification in verifications:
            nm_id = verification["nm_id"]
            accuracy = verification["overall_accuracy"]
            
            report["accuracy_by_product"][nm_id] = accuracy
            total_accuracy += accuracy
            
            # Accumulate totals
            total_our += verification["total_orders"]["our_result"]
            total_wb += verification["total_orders"]["wb_expected"]
            
            # Categorize accuracy
            if accuracy == 100:
                report["accuracy_distribution"]["perfect"] += 1
            elif accuracy >= 90:
                report["accuracy_distribution"]["good"] += 1
            elif accuracy >= 70:
                report["accuracy_distribution"]["fair"] += 1
            else:
                report["accuracy_distribution"]["poor"] += 1
            
            # Count issue types
            for issue in verification["issues_found"]:
                issue_type = issue.split(":")[0].strip()
                issue_counts[issue_type] = issue_counts.get(issue_type, 0) + 1
        
        report["overall_accuracy"] = total_accuracy / len(verifications)
        report["common_issues"] = {
            k: v for k, v in sorted(issue_counts.items(), key=lambda x: x[1], reverse=True)
        }
        
        # Summary statistics
        report["summary_statistics"] = {
            "total_orders_our": total_our,
            "total_orders_wb": total_wb,
            "total_difference": abs(total_our - total_wb),
            "overall_ratio": total_our / total_wb if total_wb > 0 else 0
        }
        
        # Generate recommendations
        if report["overall_accuracy"] < 90:
            report["recommendations"].append("Overall accuracy below 90% - investigate common issues")
        
        if report["accuracy_distribution"]["poor"] > 0:
            report["recommendations"].append(
                f"{report['accuracy_distribution']['poor']} products have poor accuracy (<70%) - priority fix needed"
            )
        
        most_common_issue = max(issue_counts.items(), key=lambda x: x[1]) if issue_counts else None
        if most_common_issue:
            report["recommendations"].append(
                f"Most common issue: {most_common_issue[0]} ({most_common_issue[1]} occurrences)"
            )
        
        return report
    
    @staticmethod
    def generate_test_cases(problematic_nm_ids: List[int]) -> List[Dict[str, Any]]:
        """
        Generate test cases for known problematic products.
        
        Args:
            problematic_nm_ids: List of nmIds with known issues
            
        Returns:
            List of test case definitions
        """
        test_cases = []
        
        # Known problematic case from user report
        if 163383326 in problematic_nm_ids:
            test_cases.append({
                "nm_id": 163383326,
                "expected_wb_data": {
                    "total_orders": 98,  # According to user report
                    "warehouse_breakdown": {
                        "–ö–æ—Ç–æ–≤—Å–∫": 18  # According to user report
                    }
                },
                "test_description": "User reported discrepancy case",
                "priority": "high"
            })
        
        # Add generic test structure for other cases
        for nm_id in problematic_nm_ids:
            if nm_id != 163383326:  # Skip already added
                test_cases.append({
                    "nm_id": nm_id,
                    "expected_wb_data": {
                        "total_orders": None,  # To be filled manually
                        "warehouse_breakdown": {}
                    },
                    "test_description": f"Test case for nmId {nm_id}",
                    "priority": "medium"
                })
        
        return test_cases


class AccuracyMonitor:
    """Monitor calculation accuracy over time."""
    
    def __init__(self):
        self.verification_history = []
    
    def add_verification(self, verification: Dict[str, Any]) -> None:
        """Add verification result to history."""
        verification["recorded_at"] = datetime.now().isoformat()
        self.verification_history.append(verification)
    
    def get_accuracy_trend(self, days: int = 7) -> Dict[str, Any]:
        """Get accuracy trend over specified days."""
        cutoff = datetime.now() - timedelta(days=days)
        
        recent_verifications = [
            v for v in self.verification_history 
            if datetime.fromisoformat(v["recorded_at"]) >= cutoff
        ]
        
        if not recent_verifications:
            return {"error": f"No verifications in last {days} days"}
        
        accuracies = [v["overall_accuracy"] for v in recent_verifications]
        
        return {
            "period_days": days,
            "verification_count": len(recent_verifications),
            "average_accuracy": sum(accuracies) / len(accuracies),
            "min_accuracy": min(accuracies),
            "max_accuracy": max(accuracies),
            "trend": "improving" if accuracies[-1] > accuracies[0] else "declining"
        }
```

### 5. –û–±–Ω–æ–≤–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ—Ü–µ—Å—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏

#### 5.1. –î–æ–±–∞–≤–∏—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –º–µ—Ç–æ–¥–æ–≤ –≤ —Å–µ—Ä–≤–∏—Å–µ

**–§–∞–π–ª**: `src/stock_tracker/services/product_service.py`

**–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥**:

```python
async def sync_product_with_verification(self, seller_article: str, 
                                       wildberries_article: int,
                                       expected_wb_data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Sync single product with calculation verification and detailed debugging.
    
    Args:
        seller_article: Product seller article
        wildberries_article: Product WB article (nmId)
        expected_wb_data: Expected WB data for verification (optional)
        
    Returns:
        Sync result with verification data and debugging info
    """
    try:
        logger.info(f"Starting verified sync for product {seller_article} (nmId: {wildberries_article})")
        
        # Fetch data with precise parameters (last 30 days, exclude canceled)
        orders_data, warehouse_data = await self.data_fetcher.fetch_product_data(
            seller_article=seller_article,
            wildberries_article=wildberries_article,
            orders_date_from=(datetime.now() - timedelta(days=30)).strftime("%Y-%m-%dT00:00:00")
        )
        
        # Use improved calculation with debugging
        calculator = WildberriesCalculator()
        
        # Calculate total orders with debugging
        total_orders, debug_info = calculator.calculate_total_orders_with_debug(
            orders_data, wildberries_article
        )
        
        # Calculate orders per warehouse
        warehouse_orders = {}
        for warehouse_name in debug_info["warehouse_breakdown"]:
            warehouse_orders[warehouse_name] = calculator.calculate_warehouse_orders(
                orders_data, wildberries_article, warehouse_name
            )
        
        # Validate calculation consistency
        validation = calculator.validate_orders_calculation(
            wildberries_article, total_orders, warehouse_orders
        )
        
        # Create product with corrected data
        product = Product(seller_article=seller_article, wildberries_article=wildberries_article)
        
        # Add warehouses including zero-stock ones with orders
        for warehouse_name, orders_count in warehouse_orders.items():
            stock = calculator.calculate_warehouse_stock(
                warehouse_data, wildberries_article, warehouse_name
            )
            warehouse = Warehouse(
                name=warehouse_name, 
                orders=orders_count, 
                stock=stock
            )
            product.add_warehouse(warehouse)
        
        # Perform verification if expected data provided
        verification_result = None
        if expected_wb_data:
            from stock_tracker.utils.calculation_verifier import CalculationVerifier
            
            our_calculation = {
                "total_orders": total_orders,
                "warehouse_breakdown": warehouse_orders
            }
            
            verification_result = CalculationVerifier.verify_orders_accuracy(
                wildberries_article, our_calculation, expected_wb_data
            )
        
        result = {
            "success": True,
            "product": product,
            "debug_info": debug_info,
            "validation": validation,
            "verification": verification_result,
            "calculated_totals": {
                "total_orders": total_orders,
                "warehouse_count": len(warehouse_orders),
                "total_stock": product.total_stock
            }
        }
        
        logger.info(f"‚úÖ Verified sync completed for {seller_article}")
        logger.info(f"   Total orders: {total_orders}")
        logger.info(f"   Warehouses: {len(warehouse_orders)}")
        logger.info(f"   Validation: {'‚úÖ PASSED' if validation['is_valid'] else '‚ùå FAILED'}")
        
        if verification_result:
            logger.info(f"   Verification accuracy: {verification_result['overall_accuracy']:.1f}%")
        
        return result
        
    except Exception as e:
        logger.error(f"Failed to sync product with verification: {e}")
        return {
            "success": False,
            "error": str(e),
            "product": None,
            "debug_info": None,
            "validation": None,
            "verification": None
        }
```

### 6. –°–æ–∑–¥–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –∞—Ä—Ç–∏–∫—É–ª–æ–≤

#### 6.1. –°–æ–∑–¥–∞—Ç—å —É—Ç–∏–ª–∏—Ç—É –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏

**–°–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª**: `diagnose_article_issues.py`

```python
#!/usr/bin/env python3
"""
–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –ø—Ä–æ–±–ª–µ–º —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ –∞—Ä—Ç–∏–∫—É–ª–∞–º–∏.

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
python diagnose_article_issues.py --nm-id 163383326 --expected-total 98 --expected-warehouse "–ö–æ—Ç–æ–≤—Å–∫:18"
"""

import asyncio
import argparse
import sys
from pathlib import Path
from typing import Dict, Any

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from stock_tracker.api.client import WildberriesAPIClient
from stock_tracker.api.products import WildberriesProductDataFetcher
from stock_tracker.core.calculator import WildberriesCalculator
from stock_tracker.utils.calculation_verifier import CalculationVerifier
from stock_tracker.utils.config import get_config
from stock_tracker.utils.logger import setup_logging, get_logger

logger = get_logger(__name__)


async def diagnose_article(nm_id: int, expected_total: int = None, 
                         expected_warehouses: Dict[str, int] = None) -> Dict[str, Any]:
    """
    –ü—Ä–æ–≤–æ–¥–∏—Ç –ø–æ–ª–Ω—É—é –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É –∞—Ä—Ç–∏–∫—É–ª–∞ –¥–ª—è –≤—ã—è–≤–ª–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º.
    
    Args:
        nm_id: –ù–æ–º–µ—Ä –∞—Ä—Ç–∏–∫—É–ª–∞ WB
        expected_total: –û–∂–∏–¥–∞–µ–º–æ–µ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫–∞–∑–æ–≤
        expected_warehouses: –û–∂–∏–¥–∞–µ–º—ã–µ –∑–∞–∫–∞–∑—ã –ø–æ —Å–∫–ª–∞–¥–∞–º
        
    Returns:
        –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
    """
    try:
        logger.info(f"üîç Starting diagnosis for nmId: {nm_id}")
        
        # Initialize API client
        config = get_config()
        wb_client = WildberriesAPIClient(config)
        data_fetcher = WildberriesProductDataFetcher(wb_client)
        
        # Fetch raw data
        logger.info("üì• Fetching raw data from APIs...")
        
        # Get orders for last 30 days
        from datetime import datetime, timedelta
        date_from = (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%dT00:00:00")
        
        orders_data = await data_fetcher.fetch_supplier_orders(date_from, flag=0)
        warehouse_data = await data_fetcher.fetch_complete_warehouse_remains()
        
        logger.info(f"üìä Raw data fetched:")
        logger.info(f"   Orders: {len(orders_data)} records")
        logger.info(f"   Warehouse: {len(warehouse_data)} records")
        
        # Filter for specific nmId
        logger.info(f"üéØ Filtering for nmId {nm_id}...")
        
        relevant_orders = [order for order in orders_data if order.get("nmId") == nm_id]
        relevant_warehouse = [item for item in warehouse_data if item.get("nmId") == nm_id]
        
        logger.info(f"üìã Filtered data:")
        logger.info(f"   Orders for nmId: {len(relevant_orders)}")
        logger.info(f"   Warehouse for nmId: {len(relevant_warehouse)}")
        
        # Analyze orders in detail
        logger.info("üîç Analyzing orders in detail...")
        
        calculator = WildberriesCalculator()
        total_orders, debug_info = calculator.calculate_total_orders_with_debug(
            orders_data, nm_id
        )
        
        # Calculate warehouse orders
        warehouse_orders = {}
        for warehouse_name in debug_info["warehouse_breakdown"]:
            warehouse_orders[warehouse_name] = calculator.calculate_warehouse_orders(
                orders_data, nm_id, warehouse_name
            )
        
        # Validate calculation
        validation = calculator.validate_orders_calculation(nm_id, total_orders, warehouse_orders)
        
        # Perform verification if expected data provided
        verification = None
        if expected_total is not None or expected_warehouses:
            expected_data = {
                "total_orders": expected_total,
                "warehouse_breakdown": expected_warehouses or {}
            }
            
            our_calculation = {
                "total_orders": total_orders,
                "warehouse_breakdown": warehouse_orders
            }
            
            verification = CalculationVerifier.verify_orders_accuracy(
                nm_id, our_calculation, expected_data
            )
        
        # Compile diagnosis result
        diagnosis = {
            "nm_id": nm_id,
            "timestamp": datetime.now().isoformat(),
            "raw_data": {
                "orders_count": len(orders_data),
                "warehouse_count": len(warehouse_data),
                "relevant_orders": len(relevant_orders),
                "relevant_warehouse": len(relevant_warehouse)
            },
            "calculation_results": {
                "total_orders": total_orders,
                "warehouse_orders": warehouse_orders,
                "debug_info": debug_info,
                "validation": validation
            },
            "verification": verification,
            "issues_detected": [],
            "recommendations": []
        }
        
        # Detect issues
        if not validation["is_valid"]:
            diagnosis["issues_detected"].append(
                f"Validation failed: warehouse sum ({validation['warehouse_sum']}) != "
                f"total ({validation['calculated_total']})"
            )
        
        if verification and verification["overall_accuracy"] < 100:
            diagnosis["issues_detected"].append(
                f"Accuracy issue: {verification['overall_accuracy']:.1f}% accuracy vs expected WB data"
            )
        
        # Generate recommendations
        if len(diagnosis["issues_detected"]) > 0:
            diagnosis["recommendations"].append("Review calculation logic for accuracy")
        
        if debug_info["filtered_out"]:
            diagnosis["recommendations"].append(
                f"Review {len(debug_info['filtered_out'])} filtered out records"
            )
        
        logger.info(f"‚úÖ Diagnosis completed for nmId {nm_id}")
        return diagnosis
        
    except Exception as e:
        logger.error(f"‚ùå Diagnosis failed for nmId {nm_id}: {e}")
        return {
            "nm_id": nm_id,
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }


def print_diagnosis_report(diagnosis: Dict[str, Any]) -> None:
    """–í—ã–≤–æ–¥–∏—Ç –æ—Ç—á–µ—Ç –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –≤ —á–∏—Ç–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ."""
    
    nm_id = diagnosis["nm_id"]
    print(f"\n{'='*60}")
    print(f"üîç DIAGNOSIS REPORT FOR nmId: {nm_id}")
    print(f"{'='*60}")
    
    if "error" in diagnosis:
        print(f"‚ùå ERROR: {diagnosis['error']}")
        return
    
    # Raw data info
    raw = diagnosis["raw_data"]
    print(f"\nüìä RAW DATA:")
    print(f"   Total orders in API: {raw['orders_count']}")
    print(f"   Total warehouse records: {raw['warehouse_count']}")
    print(f"   Orders for this nmId: {raw['relevant_orders']}")
    print(f"   Warehouse records for this nmId: {raw['relevant_warehouse']}")
    
    # Calculation results
    calc = diagnosis["calculation_results"]
    print(f"\nüßÆ CALCULATION RESULTS:")
    print(f"   Total orders calculated: {calc['total_orders']}")
    print(f"   Warehouses found: {len(calc['warehouse_orders'])}")
    
    print(f"\nüè≠ WAREHOUSE BREAKDOWN:")
    for warehouse, orders in calc["warehouse_orders"].items():
        print(f"   üì¶ {warehouse}: {orders} orders")
    
    # Debug info
    debug = calc["debug_info"]
    print(f"\nüîç DEBUG INFO:")
    print(f"   Records checked: {debug['total_records_checked']}")
    print(f"   Matching records: {len(debug['matching_records'])}")
    print(f"   Filtered out: {len(debug['filtered_out'])}")
    print(f"   WB warehouses orders: {debug['wb_warehouses']}")
    print(f"   MP warehouses orders: {debug['mp_warehouses']}")
    
    if debug['filtered_out']:
        print(f"\n‚ö†Ô∏è FILTERED OUT RECORDS:")
        for record in debug['filtered_out'][:5]:  # Show first 5
            print(f"   - {record['reason']}: {record['warehouse']} (type: {record['type']})")
        if len(debug['filtered_out']) > 5:
            print(f"   ... and {len(debug['filtered_out']) - 5} more")
    
    # Validation
    validation = calc["validation"]
    print(f"\n‚úÖ VALIDATION:")
    print(f"   Valid: {'‚úÖ YES' if validation['is_valid'] else '‚ùå NO'}")
    print(f"   Total: {validation['calculated_total']}")
    print(f"   Warehouse sum: {validation['warehouse_sum']}")
    if not validation['is_valid']:
        print(f"   ‚ö†Ô∏è Difference: {validation['difference']}")
    
    # Verification
    if diagnosis["verification"]:
        verif = diagnosis["verification"]
        print(f"\nüéØ VERIFICATION vs EXPECTED:")
        print(f"   Overall accuracy: {verif['overall_accuracy']:.1f}%")
        
        total_check = verif["total_orders"]
        print(f"   Total orders: {total_check['our_result']} vs {total_check['wb_expected']} expected")
        if not total_check['match']:
            print(f"   ‚ùå Difference: {total_check['difference']}")
        
        if verif["warehouse_orders"]:
            print(f"   Warehouse comparison:")
            for wh, data in verif["warehouse_orders"].items():
                status = "‚úÖ" if data['match'] else "‚ùå"
                print(f"     {status} {wh}: {data['our_result']} vs {data['wb_expected']} expected")
    
    # Issues and recommendations
    if diagnosis["issues_detected"]:
        print(f"\n‚ùå ISSUES DETECTED:")
        for issue in diagnosis["issues_detected"]:
            print(f"   - {issue}")
    
    if diagnosis["recommendations"]:
        print(f"\nüí° RECOMMENDATIONS:")
        for rec in diagnosis["recommendations"]:
            print(f"   - {rec}")
    
    print(f"\n{'='*60}")


async def main():
    """Main entry point for diagnosis tool."""
    parser = argparse.ArgumentParser(description="Diagnose article calculation issues")
    parser.add_argument("--nm-id", type=int, required=True, help="WB article ID (nmId)")
    parser.add_argument("--expected-total", type=int, help="Expected total orders")
    parser.add_argument("--expected-warehouse", action="append", 
                       help="Expected warehouse orders (format: 'WarehouseName:count')")
    parser.add_argument("--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR"], 
                       default="INFO", help="Log level")
    
    args = parser.parse_args()
    
    # Setup logging
    import os
    os.environ["LOG_LEVEL"] = args.log_level
    setup_logging()
    
    # Parse expected warehouse data
    expected_warehouses = {}
    if args.expected_warehouse:
        for wh_spec in args.expected_warehouse:
            try:
                name, count = wh_spec.split(":")
                expected_warehouses[name.strip()] = int(count.strip())
            except ValueError:
                print(f"‚ö†Ô∏è Invalid warehouse spec: {wh_spec} (use 'WarehouseName:count')")
    
    # Run diagnosis
    try:
        diagnosis = await diagnose_article(
            nm_id=args.nm_id,
            expected_total=args.expected_total,
            expected_warehouses=expected_warehouses if expected_warehouses else None
        )
        
        print_diagnosis_report(diagnosis)
        
    except Exception as e:
        print(f"‚ùå Diagnosis failed: {e}")
        return 1
    
    return 0


if __name__ == "__main__":
    exit(asyncio.run(main()))
```

## üöÄ –ü–õ–ê–ù –†–ï–ê–õ–ò–ó–ê–¶–ò–ò

### –§–∞–∑–∞ 1: –û—Å–Ω–æ–≤–Ω—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –í—ã—Å–æ–∫–∏–π)
1. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å `is_real_warehouse()` –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Å–∫–ª–∞–¥–æ–≤ –ú–ü
2. ‚úÖ –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å `group_data_by_product()` –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è —Å–∫–ª–∞–¥–æ–≤ —Å –Ω—É–ª–µ–≤—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏
3. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É `warehouseType` –≤ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–µ –∑–∞–∫–∞–∑–æ–≤
4. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å `calculate_total_orders_with_debug()` –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏

### –§–∞–∑–∞ 2: –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ (–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –°—Ä–µ–¥–Ω–∏–π)
1. ‚úÖ –°–æ–∑–¥–∞—Ç—å –º–æ–¥—É–ª—å `calculation_verifier.py`
2. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å `sync_product_with_verification()` –≤ —Å–µ—Ä–≤–∏—Å
3. ‚úÖ –°–æ–∑–¥–∞—Ç—å —É—Ç–∏–ª–∏—Ç—É `diagnose_article_issues.py`
4. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–Ω—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –¥–∞—Ç –≤ API

### –§–∞–∑–∞ 3: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –í—ã—Å–æ–∫–∏–π)
1. üîÑ –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Å –∞—Ä—Ç–∏–∫—É–ª–æ–º 163383326
2. üîÑ –°—Ä–∞–≤–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º WB
3. üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–∫–ª—é—á–µ–Ω–∏–µ —Å–∫–ª–∞–¥–æ–≤ –ú–ü
4. üîÑ –í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å —Å–∫–ª–∞–¥—ã —Å –Ω—É–ª–µ–≤—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏

## üìã –¢–ï–°–¢–û–í–´–ï –°–¶–ï–ù–ê–†–ò–ò

### –¢–µ—Å—Ç 1: –°–∫–ª–∞–¥—ã –ø—Ä–æ–¥–∞–≤—Ü–∞ (–ú–ü)
```bash
# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —Å–∫–ª–∞–¥—ã —Å warehouseType="–°–∫–ª–∞–¥ –ø—Ä–æ–¥–∞–≤—Ü–∞" –≤–∫–ª—é—á–µ–Ω—ã
python diagnose_article_issues.py --nm-id [TEST_ID] --log-level DEBUG
```

### –¢–µ—Å—Ç 2: –°–∫–ª–∞–¥—ã —Å –Ω—É–ª–µ–≤—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏
```bash
# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —Å–∫–ª–∞–¥—ã —Å –∑–∞–∫–∞–∑–∞–º–∏ –Ω–æ –±–µ–∑ –æ—Å—Ç–∞—Ç–∫–æ–≤ –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è
# –û–∂–∏–¥–∞–µ—Ç—Å—è: —Å–∫–ª–∞–¥—ã –ø–æ—è–≤–ª—è—é—Ç—Å—è –≤ —Å–ø–∏—Å–∫–µ —Å stock=0, orders>0
```

### –¢–µ—Å—Ç 3: –¢–æ—á–Ω–æ—Å—Ç—å –ø–æ–¥—Å—á–µ—Ç–∞ –∑–∞–∫–∞–∑–æ–≤
```bash
# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø—Ä–æ–±–ª–µ–º–Ω—ã–π –∞—Ä—Ç–∏–∫—É–ª
python diagnose_article_issues.py --nm-id 163383326 --expected-total 98 --expected-warehouse "–ö–æ—Ç–æ–≤—Å–∫:18"
```

## üìä –ö–†–ò–¢–ï–†–ò–ò –£–°–ü–ï–•–ê

1. **–°–∫–ª–∞–¥—ã –ú–ü –≤–∫–ª—é—á–µ–Ω—ã**: ‚úÖ –°–∫–ª–∞–¥—ã —Å `warehouseType="–°–∫–ª–∞–¥ –ø—Ä–æ–¥–∞–≤—Ü–∞"` –ø–æ—è–≤–ª—è—é—Ç—Å—è –≤ —Ç–∞–±–ª–∏—Ü–µ
2. **–ù—É–ª–µ–≤—ã–µ –æ—Å—Ç–∞—Ç–∫–∏ —É—á—Ç–µ–Ω—ã**: ‚úÖ –°–∫–ª–∞–¥—ã —Å –∑–∞–∫–∞–∑–∞–º–∏ –Ω–æ –Ω—É–ª–µ–≤—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏ –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è
3. **–¢–æ—á–Ω–æ—Å—Ç—å –∑–∞–∫–∞–∑–æ–≤**: ‚úÖ –†–∞—Å—Ö–æ–∂–¥–µ–Ω–∏—è —Å WB –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º —É—Å—Ç—Ä–∞–Ω–µ–Ω—ã
4. **–ê—Ä—Ç–∏–∫—É–ª 163383326**: ‚úÖ –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç 98 –∑–∞–∫–∞–∑–æ–≤ –≤—Å–µ–≥–æ –∏ 18 –¥–ª—è –ö–æ—Ç–æ–≤—Å–∫–∞

## üîß –ú–û–ù–ò–¢–û–†–ò–ù–ì –ò –ü–û–î–î–ï–†–ñ–ö–ê

–ü–æ—Å–ª–µ –≤–Ω–µ–¥—Ä–µ–Ω–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ:

1. **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ç–æ—á–Ω–æ—Å—Ç–∏**: –†–µ–≥—É–ª—è—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Å WB
2. **–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ**: –î–µ—Ç–∞–ª—å–Ω—ã–µ –ª–æ–≥–∏ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –ø—Ä–æ–±–ª–µ–º
3. **–ê–ª–µ—Ä—Ç—ã**: –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø—Ä–∏ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã—Ö —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏—è—Ö
4. **–û–±–Ω–æ–≤–ª–µ–Ω–∏—è**: –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö –≤ API WB

---

**–°—Ç–∞—Ç—É—Å**: üîÑ –ì–æ—Ç–æ–≤ –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏  
**–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ**: 23 –æ–∫—Ç—è–±—Ä—è 2025 –≥.  
**–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π**: Development Team  